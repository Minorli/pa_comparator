-- Hydra Matrix scenario (Oracle side)
-- Creates eleven schemas with complete dependency chains and cross-schema grants.
-- V2: Added idempotent cleanup section.

SET DEFINE OFF;
WHENEVER SQLERROR EXIT FAILURE;

PROMPT === Dropping existing test schemas (if they exist) ===

DECLARE
    v_sql VARCHAR2(200);
BEGIN
    FOR u IN (
        SELECT username FROM dba_users WHERE username LIKE 'ORA!_%' ESCAPE '!'
    )
    LOOP
        v_sql := 'DROP USER ' || u.username || ' CASCADE';
        BEGIN
            EXECUTE IMMEDIATE v_sql;
            DBMS_OUTPUT.PUT_LINE('Dropped user: ' || u.username);
        EXCEPTION
            WHEN OTHERS THEN
                DBMS_OUTPUT.PUT_LINE('Failed to drop user ' || u.username || ': ' || SQLERRM);
        END;
    END LOOP;
END;
/


BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_REF CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_TXN CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_DIGITAL CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_BILL CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_SEC CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_UTIL CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_AUDIT CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_PLAN CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_MDM CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_RPT CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP USER ORA_ML CASCADE';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLCODE != -1918 THEN RAISE; END IF;
END;
/


PROMPT === Creating source schemas ===

CREATE USER ORA_REF IDENTIFIED BY ora_ref_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_REF;

CREATE USER ORA_TXN IDENTIFIED BY ora_txn_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_TXN;

CREATE USER ORA_DIGITAL IDENTIFIED BY ora_digital_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TYPE, CREATE MATERIALIZED VIEW TO ORA_DIGITAL;

CREATE USER ORA_BILL IDENTIFIED BY ora_bill_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER, CREATE TYPE TO ORA_BILL;

CREATE USER ORA_SEC IDENTIFIED BY ora_sec_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE TO ORA_SEC;

CREATE USER ORA_UTIL IDENTIFIED BY ora_util_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE VIEW, CREATE SYNONYM, CREATE PROCEDURE TO ORA_UTIL;

CREATE USER ORA_AUDIT IDENTIFIED BY ora_audit_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_AUDIT;

CREATE USER ORA_PLAN IDENTIFIED BY ora_plan_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TRIGGER TO ORA_PLAN;

CREATE USER ORA_MDM IDENTIFIED BY ora_mdm_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE, CREATE TYPE TO ORA_MDM;

CREATE USER ORA_RPT IDENTIFIED BY ora_rpt_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE VIEW, CREATE PROCEDURE, CREATE MATERIALIZED VIEW TO ORA_RPT;

CREATE USER ORA_ML IDENTIFIED BY ora_ml_pass DEFAULT TABLESPACE USERS TEMPORARY TABLESPACE TEMP QUOTA UNLIMITED ON USERS;
GRANT CREATE SESSION, CREATE TABLE, CREATE VIEW, CREATE SEQUENCE, CREATE PROCEDURE TO ORA_ML;

PROMPT === ORA_REF dimensions ===

CREATE TABLE ORA_REF.REGION_DIM (
    REGION_ID      NUMBER(6)     CONSTRAINT PK_REGION_DIM PRIMARY KEY,
    REGION_CODE    VARCHAR2(20)  NOT NULL,
    REGION_NAME    VARCHAR2(120) NOT NULL,
    ACTIVE_FLAG    VARCHAR2(1)   DEFAULT 'Y' NOT NULL,
    CREATED_AT     DATE          DEFAULT SYSDATE NOT NULL,
    CONSTRAINT UK_REGION_CODE UNIQUE (REGION_CODE)
);

CREATE TABLE ORA_REF.CHANNEL_DIM (
    CHANNEL_ID     NUMBER(6)     CONSTRAINT PK_CHANNEL_DIM PRIMARY KEY,
    CHANNEL_CODE   VARCHAR2(12)  NOT NULL,
    CHANNEL_NAME   VARCHAR2(60)  NOT NULL,
    REGION_ID      NUMBER(6)     NOT NULL,
    ONLINE_FLAG    VARCHAR2(1)   DEFAULT 'N' NOT NULL,
    CONSTRAINT UK_CHANNEL_CODE UNIQUE (CHANNEL_CODE),
    CONSTRAINT FK_CHANNEL_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID)
);

CREATE TABLE ORA_REF.PRODUCT_CATEGORY (
    CATEGORY_ID    NUMBER(6)     CONSTRAINT PK_PRODUCT_CATEGORY PRIMARY KEY,
    CATEGORY_CODE  VARCHAR2(16)  NOT NULL,
    CATEGORY_NAME  VARCHAR2(120) NOT NULL,
    REGION_ID      NUMBER(6)     NOT NULL,
    DESCRIPTION    VARCHAR2(240),
    CONSTRAINT UK_PRODUCT_CODE UNIQUE (CATEGORY_CODE),
    CONSTRAINT FK_PRODUCT_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID)
);

CREATE INDEX ORA_REF.IDX_CHANNEL_REGION ON ORA_REF.CHANNEL_DIM(REGION_ID);
CREATE INDEX ORA_REF.IDX_PRODUCT_REGION ON ORA_REF.PRODUCT_CATEGORY(REGION_ID);

CREATE SEQUENCE ORA_REF.SEQ_REGION START WITH 1 INCREMENT BY 1 CACHE 50;
CREATE SEQUENCE ORA_REF.SEQ_CHANNEL START WITH 100 INCREMENT BY 1 CACHE 50;
CREATE SEQUENCE ORA_REF.SEQ_PRODUCT START WITH 1000 INCREMENT BY 5;

CREATE OR REPLACE PROCEDURE ORA_REF.SP_REFRESH_DIM AS
BEGIN
    NULL;
END;
/

PROMPT === Granting dimension access ===

GRANT SELECT, REFERENCES ON ORA_REF.REGION_DIM TO ORA_TXN, ORA_BILL, ORA_SEC, ORA_UTIL, ORA_PLAN, ORA_MDM, ORA_RPT, ORA_ML;
GRANT SELECT, REFERENCES ON ORA_REF.CHANNEL_DIM TO ORA_TXN, ORA_PLAN, ORA_RPT;
GRANT SELECT, REFERENCES ON ORA_REF.PRODUCT_CATEGORY TO ORA_TXN, ORA_PLAN, ORA_MDM;
GRANT SELECT ON ORA_REF.PRODUCT_CATEGORY TO ORA_DIGITAL, ORA_RPT;

PROMPT === ORA_TXN sales domain ===

CREATE TABLE ORA_TXN.SALES_ORDER (
    ORDER_ID        NUMBER(12)   CONSTRAINT PK_SALES_ORDER PRIMARY KEY,
    ORDER_CODE      VARCHAR2(30) NOT NULL,
    REGION_ID       NUMBER(6)    NOT NULL,
    CHANNEL_ID      NUMBER(6),
    PROMISE_DATE    DATE,
    STATUS          VARCHAR2(1)  DEFAULT 'N' NOT NULL,
    ORDER_TOTAL     NUMBER(14,2),
    CURRENCY_CODE   VARCHAR2(3)  DEFAULT 'USD',
    NOTES           VARCHAR2(400),
    CREATED_AT      DATE         DEFAULT SYSDATE,
    UPDATED_AT      DATE,
    CONSTRAINT UK_SALES_ORDER_CODE UNIQUE (ORDER_CODE),
    CONSTRAINT FK_ORDER_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID),
    CONSTRAINT FK_ORDER_CHANNEL FOREIGN KEY (CHANNEL_ID)
        REFERENCES ORA_REF.CHANNEL_DIM(CHANNEL_ID)
);

CREATE TABLE ORA_TXN.SALES_ORDER_LINE (
    ORDER_LINE_ID   NUMBER(12)   CONSTRAINT PK_SALES_ORDER_LINE PRIMARY KEY,
    ORDER_ID        NUMBER(12)   NOT NULL,
    LINE_NUMBER     NUMBER(4)    NOT NULL,
    CATEGORY_ID     NUMBER(6)    NOT NULL,
    QUANTITY        NUMBER(6)    DEFAULT 1 NOT NULL,
    UNIT_PRICE      NUMBER(12,2) NOT NULL,
    DISCOUNT_PCT    NUMBER(5,2)  DEFAULT 0,
    CONSTRAINT UK_ORDER_LINE UNIQUE (ORDER_ID, LINE_NUMBER),
    CONSTRAINT FK_LINE_ORDER FOREIGN KEY (ORDER_ID)
        REFERENCES ORA_TXN.SALES_ORDER(ORDER_ID),
    CONSTRAINT FK_LINE_CATEGORY FOREIGN KEY (CATEGORY_ID)
        REFERENCES ORA_REF.PRODUCT_CATEGORY(CATEGORY_ID)
);

CREATE INDEX ORA_TXN.IDX_ORDER_REGION ON ORA_TXN.SALES_ORDER(REGION_ID, CHANNEL_ID);
CREATE INDEX ORA_TXN.IDX_ORDER_LINE_CAT ON ORA_TXN.SALES_ORDER_LINE(CATEGORY_ID);

CREATE SEQUENCE ORA_TXN.SEQ_ORDER START WITH 5000 INCREMENT BY 1 NOCACHE;
CREATE SEQUENCE ORA_TXN.SEQ_ORDER_LINE START WITH 10000 INCREMENT BY 1 NOCACHE;

CREATE OR REPLACE TRIGGER ORA_TXN.TRG_SALES_ORDER_BI
BEFORE INSERT ON ORA_TXN.SALES_ORDER
FOR EACH ROW
BEGIN
    IF :NEW.ORDER_ID IS NULL THEN
        SELECT ORA_TXN.SEQ_ORDER.NEXTVAL INTO :NEW.ORDER_ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE ORA_TXN.SP_CLOSE_ORDER(p_order_id IN NUMBER) AS
BEGIN
    UPDATE ORA_TXN.SALES_ORDER
       SET STATUS = 'C',
           UPDATED_AT = SYSDATE
     WHERE ORDER_ID = p_order_id;
END;
/

CREATE OR REPLACE FUNCTION ORA_TXN.FN_ORDER_TOTAL(p_order_id IN NUMBER) RETURN NUMBER IS
    v_total NUMBER;
BEGIN
    SELECT SUM(UNIT_PRICE * QUANTITY * (1 - NVL(DISCOUNT_PCT, 0) / 100))
      INTO v_total
      FROM ORA_TXN.SALES_ORDER_LINE
     WHERE ORDER_ID = p_order_id;
    RETURN NVL(v_total, 0);
END;
/

CREATE OR REPLACE PACKAGE ORA_TXN.PKG_ORDER_ROUTER AS
    PROCEDURE ROUTE_ORDER(p_order_id NUMBER);
    FUNCTION ROUTE_HINT(p_region_id NUMBER, p_channel_id NUMBER) RETURN VARCHAR2;
END PKG_ORDER_ROUTER;
/

CREATE OR REPLACE PACKAGE BODY ORA_TXN.PKG_ORDER_ROUTER AS
    PROCEDURE ROUTE_ORDER(p_order_id NUMBER) IS
    BEGIN
        NULL;
    END;

    FUNCTION ROUTE_HINT(p_region_id NUMBER, p_channel_id NUMBER) RETURN VARCHAR2 IS
        v_region VARCHAR2(120);
    BEGIN
        SELECT REGION_NAME INTO v_region FROM ORA_REF.REGION_DIM WHERE REGION_ID = p_region_id;
        RETURN NVL(v_region, 'UNKNOWN') || ':' || NVL(p_channel_id, -1);
    END;
END PKG_ORDER_ROUTER;
/

-- 确保跨 schema 视图/依赖拥有直接 SELECT/REFERENCES 权限（供 ORA_TXN 视图/外键使用）
GRANT SELECT ON ORA_REF.REGION_DIM TO ORA_TXN;
GRANT SELECT ON ORA_REF.CHANNEL_DIM TO ORA_TXN;
GRANT REFERENCES ON ORA_REF.REGION_DIM TO ORA_TXN;
GRANT REFERENCES ON ORA_REF.CHANNEL_DIM TO ORA_TXN;

CREATE OR REPLACE VIEW ORA_TXN.VW_REGION_PROMISE AS
SELECT o.ORDER_ID,
       o.ORDER_CODE,
       r.REGION_NAME,
       o.PROMISE_DATE,
       o.STATUS
  FROM ORA_TXN.SALES_ORDER o
  JOIN ORA_REF.REGION_DIM r ON o.REGION_ID = r.REGION_ID
 WHERE o.STATUS <> 'C';

PROMPT === Adding new view for WITH CHECK OPTION test ===

CREATE TABLE ORA_TXN.ACTIVE_ORDERS_BASE (
    ORDER_ID   NUMBER(12) PRIMARY KEY,
    ORDER_CODE VARCHAR2(30) NOT NULL,
    STATUS     VARCHAR2(1)  NOT NULL,
    CONSTRAINT CK_ORDER_STATUS CHECK (STATUS IN ('A', 'I', 'C')) -- Active, Inactive, Closed
);

CREATE OR REPLACE VIEW ORA_TXN.V_ACTIVE_ORDERS_CHECK AS
SELECT ORDER_ID, ORDER_CODE, STATUS
  FROM ORA_TXN.ACTIVE_ORDERS_BASE
 WHERE STATUS = 'A'
  WITH CHECK OPTION;

INSERT INTO ORA_TXN.ACTIVE_ORDERS_BASE VALUES (1, 'ORD-001', 'A');
INSERT INTO ORA_TXN.ACTIVE_ORDERS_BASE VALUES (2, 'ORD-002', 'I');
COMMIT;

PROMPT === Sharing ORA_TXN objects ===

GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_DIGITAL, ORA_BILL, ORA_SEC, ORA_UTIL, ORA_AUDIT, ORA_PLAN, ORA_RPT, ORA_ML;
GRANT SELECT ON ORA_TXN.SALES_ORDER_LINE TO ORA_DIGITAL, ORA_BILL, ORA_PLAN, ORA_RPT;
GRANT REFERENCES ON ORA_TXN.SALES_ORDER_LINE TO ORA_BILL, ORA_PLAN;
GRANT REFERENCES ON ORA_TXN.SALES_ORDER TO ORA_DIGITAL, ORA_BILL, ORA_SEC, ORA_AUDIT;
GRANT SELECT ON ORA_TXN.VW_REGION_PROMISE TO ORA_RPT;

PROMPT === ORA_DIGITAL streaming / features ===

CREATE TABLE ORA_DIGITAL.STREAM_EVENT (
    EVENT_ID     NUMBER(12) CONSTRAINT PK_STREAM_EVENT PRIMARY KEY,
    ORDER_ID     NUMBER(12) NOT NULL,
    EVENT_TYPE   VARCHAR2(30) NOT NULL,
    EVENT_TS     DATE        DEFAULT SYSDATE NOT NULL,
    PAYLOAD      CLOB,
    CONSTRAINT FK_EVENT_ORDER FOREIGN KEY (ORDER_ID)
        REFERENCES ORA_TXN.SALES_ORDER(ORDER_ID)
);

CREATE SEQUENCE ORA_DIGITAL.SEQ_EVENT START WITH 1 INCREMENT BY 1;

CREATE MATERIALIZED VIEW ORA_DIGITAL.MV_EVENT_AGG
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
AS
SELECT EVENT_TYPE,
       TRUNC(EVENT_TS) AS EVENT_DAY,
       COUNT(*) AS EVENT_COUNT
  FROM ORA_DIGITAL.STREAM_EVENT
 GROUP BY EVENT_TYPE, TRUNC(EVENT_TS);

CREATE TYPE ORA_DIGITAL.T_FEATURE_VECTOR AS OBJECT (
    FEATURE_KEY   VARCHAR2(30),
    FEATURE_VALUE NUMBER,
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2
);
/

CREATE TYPE BODY ORA_DIGITAL.T_FEATURE_VECTOR AS
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2 IS
    BEGIN
        RETURN FEATURE_KEY || ':' || TO_CHAR(FEATURE_VALUE);
    END;
END;
/

CREATE OR REPLACE PROCEDURE ORA_DIGITAL.SP_RECALC_FEATURES(p_order_id IN NUMBER) AS
    v_feat ORA_DIGITAL.T_FEATURE_VECTOR := ORA_DIGITAL.T_FEATURE_VECTOR('COUNT', 1);
BEGIN
    IF v_feat.AS_TEXT IS NULL THEN
        NULL;
    END IF;
END;
/

GRANT SELECT ON ORA_DIGITAL.STREAM_EVENT TO ORA_RPT, ORA_ML;
GRANT SELECT ON ORA_DIGITAL.MV_EVENT_AGG TO ORA_RPT;

PROMPT === ORA_BILL invoicing ===

CREATE TABLE ORA_BILL.INVOICE_HEADER (
    INVOICE_ID    NUMBER(12) CONSTRAINT PK_INVOICE_HEADER PRIMARY KEY,
    ORDER_ID      NUMBER(12) NOT NULL,
    CUSTOMER_REGION NUMBER(6),
    STATUS        VARCHAR2(1) DEFAULT 'N',
    INVOICE_TOTAL NUMBER(14,2),
    DUE_DATE      DATE         NOT NULL,
    POSTED_AT     DATE,
    CONSTRAINT FK_INV_ORDER FOREIGN KEY (ORDER_ID)
        REFERENCES ORA_TXN.SALES_ORDER(ORDER_ID)
);

CREATE TABLE ORA_BILL.INVOICE_LINE (
    INVOICE_LINE_ID NUMBER(12) CONSTRAINT PK_INVOICE_LINE PRIMARY KEY,
    INVOICE_ID      NUMBER(12) NOT NULL,
    LINE_NUMBER     NUMBER(4)  NOT NULL,
    DESCRIPTION     VARCHAR2(120),
    AMOUNT          NUMBER(12,2),
    CONSTRAINT UK_INVOICE_LINE UNIQUE (INVOICE_ID, LINE_NUMBER),
    CONSTRAINT FK_INVOICE_LINE FOREIGN KEY (INVOICE_ID)
        REFERENCES ORA_BILL.INVOICE_HEADER(INVOICE_ID)
);

CREATE INDEX ORA_BILL.IDX_INV_HEADER_ORDER ON ORA_BILL.INVOICE_HEADER(ORDER_ID);

CREATE SEQUENCE ORA_BILL.SEQ_INVOICE START WITH 9000 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER ORA_BILL.TRG_INVOICE_HEADER_BI
BEFORE INSERT ON ORA_BILL.INVOICE_HEADER
FOR EACH ROW
BEGIN
    IF :NEW.INVOICE_ID IS NULL THEN
        SELECT ORA_BILL.SEQ_INVOICE.NEXTVAL INTO :NEW.INVOICE_ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE ORA_BILL.SP_POST_INVOICE(p_invoice_id IN NUMBER) AS
BEGIN
    UPDATE ORA_BILL.INVOICE_HEADER
       SET STATUS = 'P',
           POSTED_AT = SYSDATE
     WHERE INVOICE_ID = p_invoice_id;
END;
/

CREATE OR REPLACE PACKAGE ORA_BILL.PKG_BILLING_CORE AS
    PROCEDURE RELEASE_INVOICE(p_invoice_id NUMBER);
    FUNCTION CALC_BALANCE(p_invoice_id NUMBER) RETURN NUMBER;
END;
/

CREATE OR REPLACE PACKAGE BODY ORA_BILL.PKG_BILLING_CORE AS
    PROCEDURE RELEASE_INVOICE(p_invoice_id NUMBER) IS
    BEGIN
        ORA_BILL.SP_POST_INVOICE(p_invoice_id);
    END;

    FUNCTION CALC_BALANCE(p_invoice_id NUMBER) RETURN NUMBER IS
        v_total NUMBER;
    BEGIN
        SELECT NVL(INVOICE_TOTAL,0)
          INTO v_total
          FROM ORA_BILL.INVOICE_HEADER
         WHERE INVOICE_ID = p_invoice_id;
        RETURN v_total;
    END;
END;
/

CREATE TYPE ORA_BILL.T_INVOICE_SUMMARY AS OBJECT (
    INVOICE_ID    NUMBER,
    STATUS        VARCHAR2(1),
    AMOUNT        NUMBER,
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2
);
/

CREATE TYPE BODY ORA_BILL.T_INVOICE_SUMMARY AS
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2 IS
    BEGIN
        RETURN TO_CHAR(INVOICE_ID) || ':' || STATUS || ':' || TO_CHAR(AMOUNT);
    END;
END;
/

CREATE OR REPLACE VIEW ORA_BILL.VW_OVERDUE_INVOICE AS
SELECT INVOICE_ID, ORDER_ID, INVOICE_TOTAL, DUE_DATE
  FROM ORA_BILL.INVOICE_HEADER
 WHERE STATUS <> 'P'
   AND DUE_DATE < TRUNC(SYSDATE);

GRANT SELECT ON ORA_BILL.INVOICE_HEADER TO ORA_UTIL, ORA_RPT;
GRANT SELECT ON ORA_BILL.INVOICE_LINE TO ORA_RPT;
GRANT EXECUTE ON ORA_BILL.SP_POST_INVOICE TO ORA_UTIL, ORA_PLAN, ORA_RPT;

PROMPT === ORA_SEC security ===

CREATE TABLE ORA_SEC.ROLE_POLICY (
    ROLE_CODE       VARCHAR2(30) NOT NULL,
    PRIVILEGE_CODE  VARCHAR2(30) NOT NULL,
    TARGET_RESOURCE VARCHAR2(60),
    CONSTRAINT PK_ROLE_POLICY PRIMARY KEY (ROLE_CODE, PRIVILEGE_CODE)
);

CREATE TABLE ORA_SEC.USER_MATRIX (
    USER_ID       NUMBER(10) CONSTRAINT PK_USER_MATRIX PRIMARY KEY,
    LOGIN_NAME    VARCHAR2(60) NOT NULL,
    ROLE_CODE     VARCHAR2(30) NOT NULL,
    LAST_ORDER_ID NUMBER(12),
    ACTIVE_FLAG   VARCHAR2(1) DEFAULT 'Y',
    CONSTRAINT UK_USER_LOGIN UNIQUE (LOGIN_NAME),
    CONSTRAINT FK_USER_LAST_ORDER FOREIGN KEY (LAST_ORDER_ID)
        REFERENCES ORA_TXN.SALES_ORDER(ORDER_ID)
);

CREATE SEQUENCE ORA_SEC.SEQ_USER START WITH 3000 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE ORA_SEC.SP_GRANT_ROLE(p_user_id IN NUMBER, p_role IN VARCHAR2) AS
BEGIN
    UPDATE ORA_SEC.USER_MATRIX
       SET ROLE_CODE = p_role
     WHERE USER_ID = p_user_id;
END;
/

CREATE OR REPLACE FUNCTION ORA_SEC.FN_IS_ALLOWED(p_role IN VARCHAR2, p_priv IN VARCHAR2) RETURN VARCHAR2 IS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*)
      INTO v_cnt
      FROM ORA_SEC.ROLE_POLICY
     WHERE ROLE_CODE = p_role
       AND PRIVILEGE_CODE = p_priv;
    RETURN CASE WHEN v_cnt > 0 THEN 'Y' ELSE 'N' END;
END;
/

CREATE OR REPLACE VIEW ORA_SEC.VW_ACTIVE_USERS AS
SELECT USER_ID, LOGIN_NAME, ROLE_CODE
  FROM ORA_SEC.USER_MATRIX
 WHERE ACTIVE_FLAG = 'Y';

PROMPT === ORA_UTIL integration helpers ===

GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_UTIL;
GRANT SELECT ON ORA_REF.REGION_DIM TO ORA_UTIL;
GRANT SELECT ON ORA_BILL.INVOICE_HEADER TO ORA_UTIL;
GRANT EXECUTE ON ORA_BILL.SP_POST_INVOICE TO ORA_UTIL;

CREATE SYNONYM ORA_UTIL.SYN_ORDER FOR ORA_TXN.SALES_ORDER;
CREATE SYNONYM ORA_UTIL.SYN_REGION FOR ORA_REF.REGION_DIM;
CREATE SYNONYM ORA_UTIL.SYN_INVOICE FOR ORA_BILL.INVOICE_HEADER;
CREATE SYNONYM ORA_UTIL.SYN_POST_PROC FOR ORA_BILL.SP_POST_INVOICE;

CREATE OR REPLACE FUNCTION ORA_UTIL.FN_CANARY RETURN VARCHAR2 AS
BEGIN
    RETURN 'UTIL_OK';
END;
/

CREATE OR REPLACE PROCEDURE ORA_UTIL.SP_REFRESH_GATEWAY AS
BEGIN
    NULL;
END;
/

PROMPT === ORA_AUDIT logging ===

GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_AUDIT;

CREATE TABLE ORA_AUDIT.AUDIT_LOG (
    AUDIT_ID    NUMBER(12) CONSTRAINT PK_AUDIT_LOG PRIMARY KEY,
    ORDER_ID    NUMBER(12) NOT NULL,
    ACTION_CODE VARCHAR2(20) NOT NULL,
    ACTION_TS   DATE        DEFAULT SYSDATE NOT NULL,
    DETAIL      VARCHAR2(200),
    CONSTRAINT FK_AUDIT_ORDER FOREIGN KEY (ORDER_ID)
        REFERENCES ORA_TXN.SALES_ORDER(ORDER_ID)
);

CREATE TABLE ORA_AUDIT.JOB_STATUS (
    JOB_ID    NUMBER(6) CONSTRAINT PK_JOB_STATUS PRIMARY KEY,
    JOB_NAME  VARCHAR2(60) CONSTRAINT UK_JOB_NAME UNIQUE,
    LAST_RUN  DATE,
    STATUS    VARCHAR2(1) DEFAULT 'S'
);

CREATE SEQUENCE ORA_AUDIT.SEQ_AUDIT START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE TRIGGER ORA_AUDIT.TRG_AUDIT_LOG_BI
BEFORE INSERT ON ORA_AUDIT.AUDIT_LOG
FOR EACH ROW
BEGIN
    IF :NEW.AUDIT_ID IS NULL THEN
        SELECT ORA_AUDIT.SEQ_AUDIT.NEXTVAL INTO :NEW.AUDIT_ID FROM DUAL;
    END IF;
END;
/

CREATE OR REPLACE PROCEDURE ORA_AUDIT.SP_ARCHIVE_LOG AS
BEGIN
    INSERT INTO ORA_AUDIT.JOB_STATUS(JOB_ID, JOB_NAME, LAST_RUN, STATUS)
    VALUES (NVL((SELECT MAX(JOB_ID) FROM ORA_AUDIT.JOB_STATUS),0) + 1, 'ARCHIVE', SYSDATE, 'S');
END;
/

CREATE OR REPLACE FUNCTION ORA_AUDIT.FN_LAST_JOB RETURN DATE IS
    v_dt DATE;
BEGIN
    SELECT MAX(LAST_RUN) INTO v_dt FROM ORA_AUDIT.JOB_STATUS;
    RETURN v_dt;
END;
/

CREATE OR REPLACE VIEW ORA_AUDIT.VW_AUDIT_SUMMARY AS
SELECT ORDER_ID, ACTION_CODE, COUNT(*) CNT
  FROM ORA_AUDIT.AUDIT_LOG
 GROUP BY ORDER_ID, ACTION_CODE;

PROMPT === ORA_PLAN forecasting ===

GRANT SELECT ON ORA_REF.REGION_DIM TO ORA_PLAN;
GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_PLAN;
GRANT SELECT ON ORA_TXN.SALES_ORDER_LINE TO ORA_PLAN;

CREATE TABLE ORA_PLAN.FORECAST_PLAN (
    PLAN_ID        NUMBER(12) CONSTRAINT PK_FORECAST_PLAN PRIMARY KEY,
    REGION_ID      NUMBER(6)  NOT NULL,
    SNAPSHOT_DATE  DATE       DEFAULT TRUNC(SYSDATE),
    DEMAND_TOTAL   NUMBER(14,2),
    STATUS         VARCHAR2(1) DEFAULT 'N',
    CONSTRAINT FK_PLAN_REGION FOREIGN KEY (REGION_ID)
        REFERENCES ORA_REF.REGION_DIM(REGION_ID)
);

CREATE SEQUENCE ORA_PLAN.SEQ_PLAN START WITH 100 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE ORA_PLAN.SP_PUBLISH_PLAN(p_plan_id IN NUMBER) AS
BEGIN
    UPDATE ORA_PLAN.FORECAST_PLAN
       SET STATUS = 'P'
     WHERE PLAN_ID = p_plan_id;
END;
/

CREATE OR REPLACE PACKAGE ORA_PLAN.PKG_PLAN_SIM AS
    PROCEDURE RUN_REGION_SIM(p_region_id NUMBER);
    FUNCTION PLAN_STATUS(p_plan_id NUMBER) RETURN VARCHAR2;
END;
/

CREATE OR REPLACE PACKAGE BODY ORA_PLAN.PKG_PLAN_SIM AS
    PROCEDURE RUN_REGION_SIM(p_region_id NUMBER) IS
        v_cnt NUMBER;
    BEGIN
        SELECT COUNT(*) INTO v_cnt FROM ORA_TXN.SALES_ORDER WHERE REGION_ID = p_region_id;
        IF v_cnt = 0 THEN
            INSERT INTO ORA_PLAN.FORECAST_PLAN(PLAN_ID, REGION_ID, DEMAND_TOTAL)
            VALUES (ORA_PLAN.SEQ_PLAN.NEXTVAL, p_region_id, 0);
        END IF;
    END;

    FUNCTION PLAN_STATUS(p_plan_id NUMBER) RETURN VARCHAR2 IS
        v_status VARCHAR2(1);
    BEGIN
        SELECT STATUS INTO v_status FROM ORA_PLAN.FORECAST_PLAN WHERE PLAN_ID = p_plan_id;
        RETURN v_status;
    END;
END;
/

PROMPT === ORA_MDM attribute management ===

CREATE TABLE ORA_MDM.ATTRIBUTE_DEF (
    ATTR_ID     NUMBER(8)  CONSTRAINT PK_ATTRIBUTE_DEF PRIMARY KEY,
    ATTR_CODE   VARCHAR2(30) NOT NULL,
    ATTR_NAME   VARCHAR2(120) NOT NULL,
    SRC_SCHEMA  VARCHAR2(30),
    SRC_OBJECT  VARCHAR2(30)
);

CREATE SEQUENCE ORA_MDM.SEQ_ATTR START WITH 1 INCREMENT BY 1;

CREATE TYPE ORA_MDM.T_DESC_LIST AS OBJECT (
    ENTRY VARCHAR2(120),
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2
);
/

CREATE TYPE BODY ORA_MDM.T_DESC_LIST AS
    MEMBER FUNCTION AS_TEXT RETURN VARCHAR2 IS
    BEGIN
        RETURN ENTRY;
    END;
END;
/

CREATE OR REPLACE PROCEDURE ORA_MDM.SP_REFRESH_ATTRIBUTE AS
BEGIN
    INSERT INTO ORA_MDM.ATTRIBUTE_DEF(ATTR_ID, ATTR_CODE, ATTR_NAME)
    VALUES (ORA_MDM.SEQ_ATTR.NEXTVAL, 'AUTO', 'AUTOGEN');
END;
/

PROMPT === ORA_RPT reporting ===

GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_RPT;
GRANT SELECT ON ORA_TXN.SALES_ORDER_LINE TO ORA_RPT;
GRANT SELECT ON ORA_REF.REGION_DIM TO ORA_RPT;
GRANT SELECT ON ORA_DIGITAL.MV_EVENT_AGG TO ORA_RPT;
GRANT SELECT ON ORA_BILL.INVOICE_HEADER TO ORA_RPT;
GRANT REFERENCES ON ORA_REF.REGION_DIM TO ORA_RPT;

CREATE OR REPLACE VIEW ORA_RPT.VW_ORDER_REGION AS
SELECT o.ORDER_ID,
       r.REGION_NAME,
       o.STATUS,
       o.ORDER_TOTAL
  FROM ORA_TXN.SALES_ORDER o
  JOIN ORA_REF.REGION_DIM r ON o.REGION_ID = r.REGION_ID;

CREATE MATERIALIZED VIEW ORA_RPT.MV_MARGIN_ROLLUP
BUILD IMMEDIATE
REFRESH COMPLETE ON DEMAND
AS
SELECT r.REGION_NAME,
       SUM(o.ORDER_TOTAL) AS TOTAL_AMOUNT
  FROM ORA_TXN.SALES_ORDER o
  JOIN ORA_REF.REGION_DIM r ON o.REGION_ID = r.REGION_ID
 GROUP BY r.REGION_NAME;

CREATE OR REPLACE PROCEDURE ORA_RPT.SP_REFRESH_REPORTS AS
BEGIN
    NULL;
END;
/

PROMPT === ORA_ML machine learning metadata ===

GRANT SELECT ON ORA_DIGITAL.STREAM_EVENT TO ORA_ML;
GRANT SELECT ON ORA_TXN.SALES_ORDER TO ORA_ML;

CREATE TABLE ORA_ML.MODEL_VERSION (
    MODEL_ID     NUMBER(8)  CONSTRAINT PK_MODEL_VERSION PRIMARY KEY,
    VERSION_NO   VARCHAR2(20) NOT NULL,
    STATUS       VARCHAR2(1)  DEFAULT 'D',
    OWNER_name   VARCHAR2(60),
    CREATED_AT   DATE DEFAULT SYSDATE
);

CREATE TABLE ORA_ML.MODEL_RUN (
    RUN_ID       NUMBER(10) CONSTRAINT PK_MODEL_RUN PRIMARY KEY,
    MODEL_ID     NUMBER(8)  NOT NULL,
    ORDER_ID     NUMBER(12),
    SCORE        NUMBER(10,4),
    RUN_TS       DATE DEFAULT SYSDATE,
    CONSTRAINT FK_MODEL_RUN FOREIGN KEY (MODEL_ID)
        REFERENCES ORA_ML.MODEL_VERSION(MODEL_ID)
);

CREATE SEQUENCE ORA_ML.SEQ_MODEL START WITH 1 INCREMENT BY 1;

CREATE OR REPLACE PROCEDURE ORA_ML.SP_REGISTER_MODEL(
    p_model_id  IN NUMBER,
    p_version   IN VARCHAR2
) AS
BEGIN
    INSERT INTO ORA_ML.MODEL_VERSION(MODEL_ID, VERSION_NO, STATUS)
    VALUES (p_model_id, p_version, 'A');
END;
/

CREATE OR REPLACE FUNCTION ORA_ML.FN_SCORE_MODEL(
    p_model_id IN NUMBER,
    p_order_id IN NUMBER
) RETURN NUMBER IS
    v_score NUMBER := 0;
BEGIN
    SELECT NVL(ORDER_TOTAL, 0) INTO v_score FROM ORA_TXN.SALES_ORDER WHERE ORDER_ID = p_order_id;
    RETURN v_score / 100;
END;
/

PROMPT === Oracle source setup complete ===
