-- Gorgon's Knot - Oracle Setup

-- Drop users if they exist to ensure a clean slate on every run
DECLARE
    PROCEDURE drop_user(p_name VARCHAR2) IS
    BEGIN
        EXECUTE IMMEDIATE 'DROP USER ' || p_name || ' CASCADE';
    EXCEPTION
        WHEN OTHERS THEN
            IF SQLCODE != -1918 THEN -- ORA-01918: user does not exist
                RAISE;
            END IF;
    END;
BEGIN
    drop_user('HERO_A');
    drop_user('HERO_B');
    drop_user('MONSTER_A');
    drop_user('MONSTER_B');
    drop_user('GOD_A');
END;
/

-- Create users
CREATE USER HERO_A IDENTIFIED BY oracle;
CREATE USER HERO_B IDENTIFIED BY oracle;
CREATE USER MONSTER_A IDENTIFIED BY oracle;
CREATE USER MONSTER_B IDENTIFIED BY oracle;
CREATE USER GOD_A IDENTIFIED BY oracle;

-- Skip system privilege grants to stay compatible with restricted roles; DDL below is run as the installer.
ALTER USER HERO_A QUOTA UNLIMITED ON USERS;
ALTER USER HERO_B QUOTA UNLIMITED ON USERS;
ALTER USER MONSTER_A QUOTA UNLIMITED ON USERS;
ALTER USER MONSTER_B QUOTA UNLIMITED ON USERS;
ALTER USER GOD_A QUOTA UNLIMITED ON USERS;

---------------------------------------------------
-- Schema: HERO_B (created first to support cross-schema views)
---------------------------------------------------
CREATE TABLE HERO_B.LEGENDS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL,
    EPOCH VARCHAR2(50),
    STATUS VARCHAR2(20) DEFAULT 'ACTIVE'
);
CREATE SEQUENCE HERO_B.SEQ_LEGEND;

CREATE TABLE HERO_B.TREASURES (
    ID NUMBER PRIMARY KEY,
    OWNER_ID NUMBER REFERENCES HERO_B.LEGENDS(ID),
    DESCRIPTION VARCHAR2(200),
    MAGIC_LEVEL NUMBER,
    ACQUIRED_ON DATE DEFAULT SYSDATE
);
CREATE SEQUENCE HERO_B.SEQ_TREASURE_B;

CREATE TABLE HERO_B.QUESTS (
    ID NUMBER PRIMARY KEY,
    LEGEND_ID NUMBER REFERENCES HERO_B.LEGENDS(ID),
    NAME VARCHAR2(100),
    STATUS VARCHAR2(30),
    RANK NUMBER DEFAULT 0
);
CREATE SEQUENCE HERO_B.SEQ_QUEST;
CREATE OR REPLACE TRIGGER HERO_B.TRG_QUEST_BI
BEFORE INSERT ON HERO_B.QUESTS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_B.SEQ_QUEST.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_B.QUEST_STEPS (
    ID NUMBER PRIMARY KEY,
    QUEST_ID NUMBER REFERENCES HERO_B.QUESTS(ID),
    STEP_NAME VARCHAR2(100),
    COMPLETE_FLAG CHAR(1) DEFAULT 'N'
);
CREATE SEQUENCE HERO_B.SEQ_QUEST_STEP;
CREATE OR REPLACE TRIGGER HERO_B.TRG_QUEST_STEP_BI
BEFORE INSERT ON HERO_B.QUEST_STEPS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_B.SEQ_QUEST_STEP.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_B.LEGEND_AWARDS (
    ID NUMBER PRIMARY KEY,
    LEGEND_ID NUMBER REFERENCES HERO_B.LEGENDS(ID),
    AWARD VARCHAR2(100),
    AWARD_YEAR NUMBER
);
CREATE SEQUENCE HERO_B.SEQ_LEGEND_AWARD;
CREATE OR REPLACE TRIGGER HERO_B.TRG_LEGEND_AWARD_BI
BEFORE INSERT ON HERO_B.LEGEND_AWARDS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_B.SEQ_LEGEND_AWARD.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_B.LEGEND_SCROLLS (
    ID NUMBER PRIMARY KEY,
    LEGEND_ID NUMBER REFERENCES HERO_B.LEGENDS(ID),
    TITLE VARCHAR2(100),
    SECRET_CODE VARCHAR2(20)
);
CREATE SEQUENCE HERO_B.SEQ_SCROLL;
CREATE OR REPLACE TRIGGER HERO_B.TRG_SCROLL_BI
BEFORE INSERT ON HERO_B.LEGEND_SCROLLS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_B.SEQ_SCROLL.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_B.BATTLE_RECORDS (
    ID NUMBER PRIMARY KEY,
    LEGEND_ID NUMBER REFERENCES HERO_B.LEGENDS(ID),
    OPPONENT_NAME VARCHAR2(100),
    RESULT VARCHAR2(20)
);
CREATE SEQUENCE HERO_B.SEQ_BATTLE;
CREATE OR REPLACE TRIGGER HERO_B.TRG_BATTLE_BI
BEFORE INSERT ON HERO_B.BATTLE_RECORDS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_B.SEQ_BATTLE.NEXTVAL;
    END IF;
END;
/

CREATE OR REPLACE VIEW HERO_B.VW_ACTIVE_QUESTS AS
SELECT q.ID, q.NAME, q.STATUS, COUNT(s.ID) AS STEP_COUNT
FROM HERO_B.QUESTS q
LEFT JOIN HERO_B.QUEST_STEPS s ON q.ID = s.QUEST_ID
WHERE q.STATUS <> 'ARCHIVED'
GROUP BY q.ID, q.NAME, q.STATUS;

CREATE OR REPLACE FUNCTION HERO_B.FN_LEGEND_SCORE (p_legend_id IN NUMBER) RETURN NUMBER AS
    v_wins NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_wins
    FROM HERO_B.BATTLE_RECORDS
    WHERE LEGEND_ID = p_legend_id
      AND RESULT = 'WIN';
    RETURN v_wins;
END;
/

CREATE OR REPLACE PROCEDURE HERO_B.PR_CHRONICLE_LEGEND (p_name IN VARCHAR2) AS
BEGIN
    INSERT INTO HERO_B.LEGENDS (ID, NAME, EPOCH) VALUES (HERO_B.SEQ_LEGEND.NEXTVAL, p_name, 'Current');
END;
/

CREATE OR REPLACE PROCEDURE HERO_B.PR_GRANT_TREASURE (p_legend_id IN NUMBER, p_desc IN VARCHAR2, p_magic IN NUMBER) AS
BEGIN
    INSERT INTO HERO_B.TREASURES (ID, OWNER_ID, DESCRIPTION, MAGIC_LEVEL)
    VALUES (HERO_B.SEQ_TREASURE_B.NEXTVAL, p_legend_id, p_desc, p_magic);
END;
/

CREATE OR REPLACE PACKAGE HERO_B.PKG_LEGEND_ARCHIVE AS
  PROCEDURE LOG_SCROLL(p_legend_id IN NUMBER, p_title IN VARCHAR2);
  FUNCTION RECENT_SCROLLS(p_legend_id IN NUMBER) RETURN NUMBER;
END Pkg_Legend_Archive;
/
CREATE OR REPLACE PACKAGE BODY HERO_B.PKG_LEGEND_ARCHIVE AS
  PROCEDURE LOG_SCROLL(p_legend_id IN NUMBER, p_title IN VARCHAR2) IS
  BEGIN
    INSERT INTO HERO_B.LEGEND_SCROLLS (ID, LEGEND_ID, TITLE) VALUES (HERO_B.SEQ_SCROLL.NEXTVAL, p_legend_id, p_title);
  END;

  FUNCTION RECENT_SCROLLS(p_legend_id IN NUMBER) RETURN NUMBER IS
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt FROM HERO_B.LEGEND_SCROLLS WHERE LEGEND_ID = p_legend_id;
    RETURN v_cnt;
  END;
END Pkg_Legend_Archive;
/

-- Cross-schema permissions provided up front so dependent objects compile
GRANT SELECT ON HERO_B.LEGENDS TO HERO_A;
GRANT SELECT ON HERO_B.TREASURES TO HERO_A;
GRANT SELECT ON HERO_B.BATTLE_RECORDS TO HERO_A;
GRANT SELECT ON HERO_B.QUESTS TO HERO_A;
GRANT SELECT ON HERO_B.QUEST_STEPS TO HERO_A;
GRANT EXECUTE ON HERO_B.PR_CHRONICLE_LEGEND TO HERO_A;
GRANT EXECUTE ON HERO_B.PR_GRANT_TREASURE TO HERO_A;
GRANT EXECUTE ON HERO_B.PKG_LEGEND_ARCHIVE TO HERO_A;
GRANT EXECUTE ON HERO_B.FN_LEGEND_SCORE TO HERO_A;

GRANT EXECUTE ON HERO_B.PR_CHRONICLE_LEGEND TO GOD_A;
GRANT EXECUTE ON HERO_B.FN_LEGEND_SCORE TO GOD_A;

---------------------------------------------------
-- Schema: HERO_A
---------------------------------------------------
CREATE TABLE HERO_A.HEROES (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) NOT NULL
);
CREATE SEQUENCE HERO_A.SEQ_HERO;

CREATE TABLE HERO_A.TREASURES (
    ID NUMBER PRIMARY KEY,
    OWNER_ID NUMBER REFERENCES HERO_A.HEROES(ID),
    DESCRIPTION VARCHAR2(200),
    VALUE NUMBER(10, 2),
    ACQUIRED_ON DATE DEFAULT SYSDATE
);

CREATE TABLE HERO_A.MISSIONS (
    ID NUMBER PRIMARY KEY,
    HERO_ID NUMBER REFERENCES HERO_A.HEROES(ID),
    NAME VARCHAR2(100),
    STATUS VARCHAR2(30),
    RISK_LEVEL NUMBER DEFAULT 0
);
CREATE SEQUENCE HERO_A.SEQ_MISSION;
CREATE OR REPLACE TRIGGER HERO_A.TRG_MISSION_BI
BEFORE INSERT ON HERO_A.MISSIONS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_A.SEQ_MISSION.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_A.MISSION_LOG (
    ID NUMBER PRIMARY KEY,
    MISSION_ID NUMBER REFERENCES HERO_A.MISSIONS(ID),
    LOG_TEXT VARCHAR2(200)
);
CREATE SEQUENCE HERO_A.SEQ_MISSION_LOG;
CREATE OR REPLACE TRIGGER HERO_A.TRG_MISSION_LOG_BI
BEFORE INSERT ON HERO_A.MISSION_LOG
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_A.SEQ_MISSION_LOG.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_A.RELICS (
    ID NUMBER PRIMARY KEY,
    OWNER_ID NUMBER REFERENCES HERO_A.HEROES(ID),
    RARITY VARCHAR2(30),
    VALUE NUMBER(10, 2)
);
CREATE SEQUENCE HERO_A.SEQ_RELIC;
CREATE OR REPLACE TRIGGER HERO_A.TRG_RELIC_BI
BEFORE INSERT ON HERO_A.RELICS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_A.SEQ_RELIC.NEXTVAL;
    END IF;
END;
/

CREATE TABLE HERO_A.HERO_TITLES (
    ID NUMBER PRIMARY KEY,
    HERO_ID NUMBER REFERENCES HERO_A.HEROES(ID),
    TITLE VARCHAR2(100),
    SOURCED_FROM VARCHAR2(50)
);
CREATE SEQUENCE HERO_A.SEQ_HERO_TITLE;
CREATE OR REPLACE TRIGGER HERO_A.TRG_HERO_TITLE_BI
BEFORE INSERT ON HERO_A.HERO_TITLES
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := HERO_A.SEQ_HERO_TITLE.NEXTVAL;
    END IF;
END;
/

CREATE OR REPLACE VIEW HERO_A.VW_HERO_STATUS AS
SELECT h.ID, h.NAME, m.STATUS, NVL(m.RISK_LEVEL, 0) AS RISK_LEVEL
FROM HERO_A.HEROES h
LEFT JOIN HERO_A.MISSIONS m ON h.ID = m.HERO_ID;

CREATE OR REPLACE VIEW HERO_A.VW_ALL_TREASURES AS
SELECT H.NAME AS HERO_NAME, 'Heroic' as TYPE, T.DESCRIPTION
FROM HERO_A.HEROES H JOIN HERO_A.TREASURES T ON H.ID = T.OWNER_ID
UNION ALL
SELECT L.NAME AS HERO_NAME, 'Legendary' as TYPE, T.DESCRIPTION
FROM HERO_B.LEGENDS L JOIN HERO_B.TREASURES T ON L.ID = T.OWNER_ID;

CREATE OR REPLACE VIEW HERO_A.VW_SHARED_BATTLES AS
SELECT H.NAME AS HERO_NAME, B.OPPONENT_NAME, B.RESULT
FROM HERO_A.HEROES H
JOIN HERO_B.BATTLE_RECORDS B ON B.OPPONENT_NAME = H.NAME;

CREATE OR REPLACE FUNCTION HERO_A.FN_HERO_NET_WORTH (p_hero_id IN NUMBER) RETURN NUMBER AS
    v_total NUMBER;
    v_legend NUMBER;
BEGIN
    SELECT NVL(SUM(VALUE), 0) INTO v_total FROM HERO_A.TREASURES WHERE OWNER_ID = p_hero_id;

    SELECT NVL(SUM(T.VALUE), 0) INTO v_legend
    FROM HERO_B.TREASURES T
    JOIN HERO_B.LEGENDS L ON L.ID = T.OWNER_ID
    WHERE L.NAME = (SELECT NAME FROM HERO_A.HEROES WHERE ID = p_hero_id);

    RETURN NVL(v_total, 0) + NVL(v_legend, 0);
END;
/

CREATE OR REPLACE PROCEDURE HERO_A.SP_TRACK_MISSION (p_hero_id IN NUMBER, p_name IN VARCHAR2, p_log IN VARCHAR2) AS
    v_mission_id NUMBER;
BEGIN
    INSERT INTO HERO_A.MISSIONS (ID, HERO_ID, NAME, STATUS) VALUES (HERO_A.SEQ_MISSION.NEXTVAL, p_hero_id, p_name, 'OPEN')
    RETURNING ID INTO v_mission_id;
    INSERT INTO HERO_A.MISSION_LOG (ID, MISSION_ID, LOG_TEXT) VALUES (HERO_A.SEQ_MISSION_LOG.NEXTVAL, v_mission_id, p_log);
END;
/

CREATE OR REPLACE PROCEDURE HERO_A.SP_REQUEST_CHRONICLE (p_hero_id IN NUMBER) AS
    v_name HERO_A.HEROES.NAME%TYPE;
BEGIN
    SELECT NAME INTO v_name FROM HERO_A.HEROES WHERE ID = p_hero_id;
    HERO_B.PR_CHRONICLE_LEGEND(v_name || ' - Recorded');
END;
/

CREATE OR REPLACE PACKAGE HERO_A.PKG_HERO_NETWORK AS
  PROCEDURE ALLY_WITH_LEGEND(p_hero_id IN NUMBER, p_legend_id IN NUMBER);
  FUNCTION COUNT_JOINT_QUESTS(p_hero_id IN NUMBER) RETURN NUMBER;
END Pkg_Hero_Network;
/
CREATE OR REPLACE PACKAGE BODY HERO_A.PKG_HERO_NETWORK AS
  PROCEDURE ALLY_WITH_LEGEND(p_hero_id IN NUMBER, p_legend_id IN NUMBER) IS
    v_title VARCHAR2(100);
  BEGIN
    SELECT NAME INTO v_title FROM HERO_A.HEROES WHERE ID = p_hero_id;
    HERO_B.PKG_LEGEND_ARCHIVE.LOG_SCROLL(p_legend_id, 'Alliance with ' || v_title);
  END;

  FUNCTION COUNT_JOINT_QUESTS(p_hero_id IN NUMBER) RETURN NUMBER IS
    v_cnt NUMBER;
    v_name VARCHAR2(100);
  BEGIN
    SELECT NAME INTO v_name FROM HERO_A.HEROES WHERE ID = p_hero_id;
    SELECT COUNT(*) INTO v_cnt
    FROM HERO_B.QUESTS q
    JOIN HERO_B.LEGENDS l ON l.ID = q.LEGEND_ID
    WHERE l.NAME = v_name;
    RETURN v_cnt;
  END;
END Pkg_Hero_Network;
/

-- Allow HERO_B and GOD_A to read HERO_A data for cross-schema checks
GRANT SELECT ON HERO_A.HEROES TO HERO_B;
GRANT SELECT ON HERO_A.MISSIONS TO HERO_B;
GRANT SELECT ON HERO_A.MISSION_LOG TO HERO_B;
GRANT SELECT ON HERO_A.HEROES TO GOD_A;
GRANT SELECT ON HERO_A.MISSIONS TO GOD_A;
GRANT EXECUTE ON HERO_A.PKG_HERO_NETWORK TO GOD_A;

CREATE OR REPLACE VIEW HERO_B.VW_SHARED_FEATS AS
SELECT l.NAME AS LEGEND_NAME, h.NAME AS HERO_NAME, m.NAME AS MISSION_NAME
FROM HERO_B.LEGENDS l
JOIN HERO_A.HEROES h ON h.NAME = l.NAME
JOIN HERO_A.MISSIONS m ON m.HERO_ID = h.ID;

---------------------------------------------------
-- Schema: MONSTER_A
---------------------------------------------------
CREATE TABLE MONSTER_A.LAIR (
    ID NUMBER PRIMARY KEY,
    LOCATION VARCHAR2(100),
    GEAR VARCHAR2(100),
    VICTIMS NUMBER
);

CREATE TABLE MONSTER_A.MINIONS (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    NAME VARCHAR2(50)
);
CREATE SEQUENCE MONSTER_A.SEQ_MINION;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_MINION_BI
BEFORE INSERT ON MONSTER_A.MINIONS
FOR EACH ROW
BEGIN
    :new.ID := MONSTER_A.SEQ_MINION.NEXTVAL;
END;
/

CREATE TABLE MONSTER_A.DUNGEONS (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    DEPTH NUMBER,
    STATUS VARCHAR2(30)
);
CREATE SEQUENCE MONSTER_A.SEQ_DUNGEON;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_DUNGEON_BI
BEFORE INSERT ON MONSTER_A.DUNGEONS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_DUNGEON.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.TRAPS (
    ID NUMBER PRIMARY KEY,
    DUNGEON_ID NUMBER REFERENCES MONSTER_A.DUNGEONS(ID),
    KIND VARCHAR2(50),
    IS_ARMED CHAR(1) DEFAULT 'Y'
);
CREATE SEQUENCE MONSTER_A.SEQ_TRAP;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_TRAP_BI
BEFORE INSERT ON MONSTER_A.TRAPS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_TRAP.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.RAIDS (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    TARGET VARCHAR2(100),
    STATUS VARCHAR2(30)
);
CREATE SEQUENCE MONSTER_A.SEQ_RAID;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_RAID_BI
BEFORE INSERT ON MONSTER_A.RAIDS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_RAID.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.CURSES (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    TARGET_HERO VARCHAR2(100),
    ACTIVE_FLAG CHAR(1) DEFAULT 'Y'
);
CREATE SEQUENCE MONSTER_A.SEQ_CURSE;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_CURSE_BI
BEFORE INSERT ON MONSTER_A.CURSES
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_CURSE.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.LAB_NOTES (
    ID NUMBER PRIMARY KEY,
    MINION_ID NUMBER REFERENCES MONSTER_A.MINIONS(ID),
    NOTE VARCHAR2(200)
);
CREATE SEQUENCE MONSTER_A.SEQ_NOTE;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_NOTE_BI
BEFORE INSERT ON MONSTER_A.LAB_NOTES
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_NOTE.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.SUPPLY_LINES (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    MATERIAL VARCHAR2(100),
    STOCK NUMBER
);
CREATE SEQUENCE MONSTER_A.SEQ_SUPPLY;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_SUPPLY_BI
BEFORE INSERT ON MONSTER_A.SUPPLY_LINES
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_SUPPLY.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_A.WAR_CHESTS (
    ID NUMBER PRIMARY KEY,
    LAIR_ID NUMBER REFERENCES MONSTER_A.LAIR(ID),
    GOLD NUMBER
);
CREATE SEQUENCE MONSTER_A.SEQ_WARCHEST;
CREATE OR REPLACE TRIGGER MONSTER_A.TRG_WARCHEST_BI
BEFORE INSERT ON MONSTER_A.WAR_CHESTS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_A.SEQ_WARCHEST.NEXTVAL;
    END IF;
END;
/

CREATE OR REPLACE VIEW MONSTER_A.VW_LAIR_RICHNESS AS
SELECT L.LOCATION, M.NAME as MINION_NAME
FROM MONSTER_A.LAIR L JOIN MONSTER_A.MINIONS M ON L.ID = M.LAIR_ID;

CREATE OR REPLACE VIEW MONSTER_A.VW_DANGER_MATRIX AS
SELECT l.ID AS LAIR_ID, COUNT(DISTINCT d.ID) AS DUNGEON_COUNT, COUNT(t.ID) AS TRAP_COUNT
FROM MONSTER_A.LAIR l
LEFT JOIN MONSTER_A.DUNGEONS d ON d.LAIR_ID = l.ID
LEFT JOIN MONSTER_A.TRAPS t ON t.DUNGEON_ID = d.ID
GROUP BY l.ID;

CREATE OR REPLACE VIEW MONSTER_A.VW_RAID_ROLLUP AS
SELECT l.LOCATION, COUNT(r.ID) AS RAID_COUNT
FROM MONSTER_A.LAIR l
LEFT JOIN MONSTER_A.RAIDS r ON r.LAIR_ID = l.ID
GROUP BY l.LOCATION;

CREATE OR REPLACE VIEW MONSTER_A.VW_SUPPLY_STATUS AS
SELECT l.LOCATION, s.MATERIAL, s.STOCK, w.GOLD
FROM MONSTER_A.LAIR l
LEFT JOIN MONSTER_A.SUPPLY_LINES s ON s.LAIR_ID = l.ID
LEFT JOIN MONSTER_A.WAR_CHESTS w ON w.LAIR_ID = l.ID;

CREATE OR REPLACE PROCEDURE MONSTER_A.SP_SUMMON_MINION(p_lair_id IN NUMBER) AS
BEGIN
    INSERT INTO MONSTER_A.MINIONS (LAIR_ID, NAME) VALUES (p_lair_id, 'Generic Minion');
END;
/

CREATE OR REPLACE PROCEDURE MONSTER_A.SP_TRAP_RESET(p_dungeon_id IN NUMBER) AS
BEGIN
    UPDATE MONSTER_A.TRAPS SET IS_ARMED = 'N' WHERE DUNGEON_ID = p_dungeon_id;
END;
/

CREATE OR REPLACE FUNCTION MONSTER_A.FN_COUNT_ACTIVE_TRAPS(p_lair_id IN NUMBER) RETURN NUMBER AS
    v_cnt NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_cnt
    FROM MONSTER_A.TRAPS t
    JOIN MONSTER_A.DUNGEONS d ON d.ID = t.DUNGEON_ID
    WHERE d.LAIR_ID = p_lair_id
      AND t.IS_ARMED = 'Y';
    RETURN v_cnt;
END;
/

CREATE OR REPLACE PACKAGE MONSTER_A.PKG_MONSTER_OPS AS
  PROCEDURE SPEND_FUNDS(p_lair_id IN NUMBER, p_amount IN NUMBER);
END Pkg_Monster_Ops;
/
CREATE OR REPLACE PACKAGE BODY MONSTER_A.PKG_MONSTER_OPS AS
  PROCEDURE SPEND_FUNDS(p_lair_id IN NUMBER, p_amount IN NUMBER) IS
    v_gold NUMBER;
  BEGIN
    SELECT GOLD INTO v_gold FROM MONSTER_A.WAR_CHESTS WHERE LAIR_ID = p_lair_id FOR UPDATE;
    UPDATE MONSTER_A.WAR_CHESTS SET GOLD = NVL(v_gold, 0) - p_amount WHERE LAIR_ID = p_lair_id;
    INSERT INTO MONSTER_A.LAB_NOTES (ID, MINION_ID, NOTE) VALUES (MONSTER_A.SEQ_NOTE.NEXTVAL, NULL, 'Spent ' || p_amount);
  END;
END Pkg_Monster_Ops;
/

-- Synonyms showcasing split mapping quirks
CREATE SYNONYM MONSTER_A.SYN_SECRET FOR MONSTER_A.LAIR;
CREATE SYNONYM MONSTER_A.SYN_FUNDS FOR MONSTER_A.WAR_CHESTS;

---------------------------------------------------
-- Schema: MONSTER_B (No remap target)
---------------------------------------------------
CREATE TABLE MONSTER_B.ABYSS (
    ID NUMBER PRIMARY KEY,
    HORROR_LEVEL NUMBER
);
CREATE SEQUENCE MONSTER_B.SEQ_ABYSS;

CREATE TABLE MONSTER_B.VOID_LOGS (
    ID NUMBER PRIMARY KEY,
    ABYSS_ID NUMBER REFERENCES MONSTER_B.ABYSS(ID),
    ENTRY VARCHAR2(200)
);
CREATE SEQUENCE MONSTER_B.SEQ_VOID_LOG;
CREATE OR REPLACE TRIGGER MONSTER_B.TRG_VOID_LOG_BI
BEFORE INSERT ON MONSTER_B.VOID_LOGS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_B.SEQ_VOID_LOG.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_B.SHADOW_ACCOUNTS (
    ID NUMBER PRIMARY KEY,
    ACCOUNT_NAME VARCHAR2(50),
    POWER_LEVEL NUMBER
);
CREATE SEQUENCE MONSTER_B.SEQ_SHADOW_ACCOUNT;
CREATE OR REPLACE TRIGGER MONSTER_B.TRG_SHADOW_ACCOUNT_BI
BEFORE INSERT ON MONSTER_B.SHADOW_ACCOUNTS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_B.SEQ_SHADOW_ACCOUNT.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_B.CURSE_BOOK (
    ID NUMBER PRIMARY KEY,
    TITLE VARCHAR2(100),
    DANGER_LEVEL NUMBER
);
CREATE SEQUENCE MONSTER_B.SEQ_CURSE_BOOK;
CREATE OR REPLACE TRIGGER MONSTER_B.TRG_CURSE_BOOK_BI
BEFORE INSERT ON MONSTER_B.CURSE_BOOK
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_B.SEQ_CURSE_BOOK.NEXTVAL;
    END IF;
END;
/

CREATE TABLE MONSTER_B.GLOOM_EVENTS (
    ID NUMBER PRIMARY KEY,
    ABYSS_ID NUMBER REFERENCES MONSTER_B.ABYSS(ID),
    DESCRIPTION VARCHAR2(200)
);
CREATE SEQUENCE MONSTER_B.SEQ_GLOOM_EVENT;
CREATE OR REPLACE TRIGGER MONSTER_B.TRG_GLOOM_EVENT_BI
BEFORE INSERT ON MONSTER_B.GLOOM_EVENTS
FOR EACH ROW
BEGIN
    IF :new.ID IS NULL THEN
        :new.ID := MONSTER_B.SEQ_GLOOM_EVENT.NEXTVAL;
    END IF;
END;
/

CREATE OR REPLACE VIEW MONSTER_B.VW_GLOOM AS
SELECT a.ID AS ABYSS_ID, COUNT(g.ID) AS EVENT_COUNT
FROM MONSTER_B.ABYSS a
LEFT JOIN MONSTER_B.GLOOM_EVENTS g ON g.ABYSS_ID = a.ID
GROUP BY a.ID;

CREATE OR REPLACE PROCEDURE MONSTER_B.SP_LOG_VOID(p_abyss_id IN NUMBER, p_entry IN VARCHAR2) AS
BEGIN
    INSERT INTO MONSTER_B.VOID_LOGS (ID, ABYSS_ID, ENTRY) VALUES (MONSTER_B.SEQ_VOID_LOG.NEXTVAL, p_abyss_id, p_entry);
END;
/

---------------------------------------------------
-- Schema: GOD_A
---------------------------------------------------
-- Cross-schema permissions for GOD_A to inspect mortals
GRANT SELECT ON HERO_B.LEGENDS TO GOD_A;
GRANT SELECT ON HERO_B.TREASURES TO GOD_A;
GRANT SELECT ON HERO_A.HEROES TO GOD_A;
GRANT SELECT ON HERO_A.MISSIONS TO GOD_A;
GRANT EXECUTE ON HERO_A.FN_HERO_NET_WORTH TO GOD_A;

CREATE TABLE GOD_A.DOMAINS (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(50)
);
CREATE SEQUENCE GOD_A.SEQ_DOMAIN;

CREATE TABLE GOD_A.PANTHEON (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100),
    DOMAIN_ID NUMBER REFERENCES GOD_A.DOMAINS(ID)
);

CREATE TABLE GOD_A.PORTALS (
    PORTAL_ID NUMBER PRIMARY KEY,
    DOMAIN_ID NUMBER REFERENCES GOD_A.DOMAINS(ID),
    DESTINATION VARCHAR2(100)
);
CREATE SEQUENCE GOD_A.SEQ_PORTAL;

CREATE TABLE GOD_A.EDICTS (
    EDICT_ID NUMBER PRIMARY KEY,
    DOMAIN_ID NUMBER REFERENCES GOD_A.DOMAINS(ID),
    TEXT VARCHAR2(200)
);
CREATE SEQUENCE GOD_A.SEQ_EDICT;

CREATE TABLE GOD_A.MIRACLES (
    MIRACLE_ID NUMBER PRIMARY KEY,
    PANTHEON_ID NUMBER REFERENCES GOD_A.PANTHEON(ID),
    TARGET_NAME VARCHAR2(100)
);
CREATE SEQUENCE GOD_A.SEQ_MIRACLE;

CREATE TABLE GOD_A.RITUALS (
    RITUAL_ID NUMBER PRIMARY KEY,
    DOMAIN_ID NUMBER REFERENCES GOD_A.DOMAINS(ID),
    RITUAL_NAME VARCHAR2(100),
    FOCUS VARCHAR2(50)
);
CREATE SEQUENCE GOD_A.SEQ_RITUAL;

CREATE TABLE GOD_A.COSMIC_EVENTS (
    EVENT_ID NUMBER PRIMARY KEY,
    PORTAL_ID NUMBER REFERENCES GOD_A.PORTALS(PORTAL_ID),
    OMEN_TEXT VARCHAR2(200)
);
CREATE SEQUENCE GOD_A.SEQ_EVENT;

CREATE OR REPLACE TYPE GOD_A.T_OMEN AS OBJECT (
  omen_id NUMBER,
  omen_text VARCHAR2(200)
);
/
CREATE OR REPLACE TYPE BODY GOD_A.T_OMEN AS
  -- No methods, just a simple type body
END;
/

CREATE OR REPLACE TYPE GOD_A.T_SIGNAL AS OBJECT (
  code VARCHAR2(30),
  severity NUMBER
);
/

CREATE OR REPLACE PACKAGE GOD_A.PKG_DIVINITY AS
  PROCEDURE MANIFEST_POWER(p_domain_id IN NUMBER);
  PROCEDURE RECORD_MIRACLE(p_pantheon_id IN NUMBER, p_target IN VARCHAR2);
END PKG_DIVINITY;
/
CREATE OR REPLACE PACKAGE BODY GOD_A.PKG_DIVINITY AS
  PROCEDURE MANIFEST_POWER(p_domain_id IN NUMBER) IS
  BEGIN
    INSERT INTO GOD_A.EDICTS (EDICT_ID, DOMAIN_ID, TEXT) VALUES (GOD_A.SEQ_EDICT.NEXTVAL, p_domain_id, 'Power acknowledged');
  END;

  PROCEDURE RECORD_MIRACLE(p_pantheon_id IN NUMBER, p_target IN VARCHAR2) IS
  BEGIN
    INSERT INTO GOD_A.MIRACLES (MIRACLE_ID, PANTHEON_ID, TARGET_NAME) VALUES (GOD_A.SEQ_MIRACLE.NEXTVAL, p_pantheon_id, p_target);
  END;
END PKG_DIVINITY;
/

CREATE OR REPLACE PACKAGE GOD_A.PKG_PROPHECY AS
  FUNCTION FORESEE_TREASURE(p_hero_id IN NUMBER) RETURN NUMBER;
  PROCEDURE LOG_PORTAL(p_domain_id IN NUMBER, p_destination IN VARCHAR2);
END PKG_PROPHECY;
/
CREATE OR REPLACE PACKAGE BODY GOD_A.PKG_PROPHECY AS
  FUNCTION FORESEE_TREASURE(p_hero_id IN NUMBER) RETURN NUMBER IS
    v_value NUMBER;
  BEGIN
    SELECT HERO_A.FN_HERO_NET_WORTH(p_hero_id) INTO v_value FROM dual;
    RETURN v_value;
  END;

  PROCEDURE LOG_PORTAL(p_domain_id IN NUMBER, p_destination IN VARCHAR2) IS
  BEGIN
    INSERT INTO GOD_A.PORTALS (PORTAL_ID, DOMAIN_ID, DESTINATION) VALUES (GOD_A.SEQ_PORTAL.NEXTVAL, p_domain_id, p_destination);
  END;
END PKG_PROPHECY;
/

CREATE OR REPLACE VIEW GOD_A.VW_DOMAIN_POWER AS
SELECT d.ID AS DOMAIN_ID, d.NAME, COUNT(e.EDICT_ID) AS EDICT_COUNT
FROM GOD_A.DOMAINS d
LEFT JOIN GOD_A.EDICTS e ON e.DOMAIN_ID = d.ID
GROUP BY d.ID, d.NAME;

CREATE OR REPLACE VIEW GOD_A.VW_MORTAL_TOUCH AS
SELECT p.NAME AS DEITY, h.NAME AS HERO_NAME, m.STATUS AS HERO_STATUS
FROM GOD_A.PANTHEON p
JOIN HERO_A.HEROES h ON h.ID = p.DOMAIN_ID
LEFT JOIN HERO_A.MISSIONS m ON m.HERO_ID = h.ID;

CREATE OR REPLACE PROCEDURE GOD_A.SP_BLESS_HERO (p_legend_name IN VARCHAR2) AS
BEGIN
    HERO_B.PR_CHRONICLE_LEGEND(p_legend_name || ' the Blessed');
END;
/

CREATE OR REPLACE PROCEDURE GOD_A.SP_OPEN_PORTAL(p_domain_id IN NUMBER, p_destination IN VARCHAR2) AS
BEGIN
    INSERT INTO GOD_A.PORTALS (PORTAL_ID, DOMAIN_ID, DESTINATION) VALUES (GOD_A.SEQ_PORTAL.NEXTVAL, p_domain_id, p_destination);
    INSERT INTO GOD_A.COSMIC_EVENTS (EVENT_ID, PORTAL_ID, OMEN_TEXT) VALUES (GOD_A.SEQ_EVENT.NEXTVAL, GOD_A.SEQ_PORTAL.CURRVAL, 'Path opened to ' || p_destination);
END;
/
