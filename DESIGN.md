# 数据库对象对比工具设计文档

本文档阐述了数据库对象对比脚本的设计思路、核心架构和工作流程。

## 1. 核心目标

这个工具用于自动对比 Oracle 和 OceanBase 数据库之间的对象，找出差异，并生成 SQL “修补”脚本，帮助用户快速同步目标数据库的结构。

主要解决以下几个痛点：
- **对象缺失**：目标库缺少源库的表、视图、索引等。
- **对象不一致**：
    - 表的列不匹配（多列或少列）。
    - 列定义不匹配（如 `VARCHAR` 长度）。
    - 索引、约束的结构不一致。
- **手动对比效率低、易出错**：对于有成百上千个对象的复杂数据库，手动排查几乎不可能完成。

## 2. 核心设计：一次转储，本地对比

为了提升性能并减少对目标库的压力，脚本采用了 **“一次转储，本地对比”** 的架构。

如果采用在循环中反复查询源和目标库的传统做法，每次只查一个对象，会产生大量网络请求，性能很差。

脚本的实际工作流程是：
1.  **连接源端 Oracle**：拿到所有要检查的对象的完整列表。
2.  **一次性转储目标端元数据**：通过 `obclient` 工具，执行几个预设的 SQL，把目标库 OceanBase 的所有相关元数据（如 `ALL_OBJECTS`, `ALL_TAB_COLUMNS` 等）一次性 dump 到本地。
3.  **在本地内存中对比**：将 dump 下来的元数据加载到 Python 的数据结构里。之后所有的对比，包括对象是否存在、列名是否匹配、索引/约束结构是否一致等，都在本地内存中完成，不再和目标数据库交互。

这个设计的优势很明显：
- **高性能**：把成千上万次远程查询优化为几次批量拉取，大大加快了校验速度。
- **低负载**：显著降低了对目标 OceanBase 数据库的查询压力。
- **逻辑清晰**：数据获取和数据分析两个阶段分开，代码结构更清晰。

## 3. 配置文件驱动

为了灵活和复用，工具的行为完全由外部配置文件驱动。

-   **`db.ini`**: 主配置文件。
    -   `[ORACLE_SOURCE]`: 源端 Oracle 的连接信息。
    -   `[OCEANBASE_TARGET]`: 目标端 OceanBase 的连接信息和 `obclient` 路径。
    -   `[SETTINGS]`: 核心校验参数，如：
        -   `source_schemas`: 要扫描的源端 schema 列表。
        -   `remap_file`: 对象名重映射规则文件的路径。
        -   `obclient_timeout`: `obclient` 执行超时时间，增强程序健壮性。

-   **`remap_rules.txt`**: 对象重映射规则。
    -   解决了不同环境中对象命名可能不一致的问题。
    -   例如，源端的 `PROD.ORDERS` 在目标端可能叫 `MIG_PROD.ORDERS`，只需在文件中写一行 `PROD.ORDERS=MIG_PROD.ORDERS` 即可。
    -   工具会根据这个规则生成最终的校验清单。

## 4. 详细工作流程

程序按以下步骤执行：

1.  **加载配置**：读取 `db.ini` 和 `remap_rules.txt`。
2.  **获取源对象**：连接 Oracle，查询 `ALL_OBJECTS`，拿到指定 schema 下所有要对比的对象列表。
3.  **验证规则**：检查 `remap_rules.txt` 里写的源对象在 Oracle 中是否存在，对无效规则给出警告。
4.  **生成主校验清单**：应用重映射规则，生成一个“源-目标”的完整映射清单。同时，检测并阻止“多对一”的非法映射。
5.  **转储 OceanBase 元数据**：根据校验清单确定要查哪些目标 schema，然后调用 `obclient` 把元数据 dump 下来，解析到内存中。
6.  **转储 Oracle 元数据**：为了避免后续生成脚本时反复查 Oracle，这里会预先批量加载所有需要的 Oracle 元数据（列定义、索引等）到内存。
7.  **执行对比**：
    -   **主对象对比**：遍历清单，检查目标对象是否存在。对表，额外对比列名。
    -   **扩展对象对比**：对已存在的表，进一步对比索引、约束和触发器。同时，按 schema 对比序列。
8.  **生成修补脚本**：
    -   根据对比结果，调用 Oracle 的 `DBMS_METADATA.GET_DDL` 获取源对象的标准 DDL。
    -   对 DDL 进行规范化和重映射处理（比如替换 schema 名）。
    -   对表的列差异，直接生成 `ALTER TABLE` 语句。
    -   所有生成的 `.sql` 脚本分类存放在 `fix_up/` 目录下，等待人工审核。
9.  **输出报告**：用 `rich` 库在控制台打印一份格式化、带高亮的详细报告，清晰展示对比结果，并指明修补脚本的存放位置。

## 5. 对象对比逻辑

-   **TABLE**:
    -   检查是否存在。
    -   对比列名集合（忽略 `OMS_` 开头的内部列）。
    -   检查 `VARCHAR`/`VARCHAR2` 列的长度（默认目标端长度应为源端 * 1.5）。
-   **VIEW, PROCEDURE, FUNCTION, PACKAGE, SYNONYM**:
    -   只检查是否存在。
-   **INDEX**:
    -   检查是否存在。
    -   对比结构：索引的列、列顺序、是否唯一。
-   **CONSTRAINT (PK/UK/FK)**:
    -   检查是否存在。
    -   对比结构：约束类型和涉及的列。
-   **SEQUENCE, TRIGGER**:
    -   只检查是否存在。

## 6. 健壮性设计

-   **超时机制**：所有 `obclient` 调用都设置了超时，防止因网络或数据库问题卡死。
-   **配置验证**：在程序早期严格校验配置文件，尽早发现错误。
-   **清晰的错误提示**：在连接失败、文件找不到、配置错误时，给出明确的错误信息并退出。
-   **依赖检查**：启动时检查 `oracledb` 和 `rich` 等关键库是否存在，引导用户安装。